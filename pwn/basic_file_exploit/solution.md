```
Hi, welcome to my echo chamber!
Type '1' to enter a phrase into our database
Type '2' to echo a phrase in our database
Type '3' to exit the program
2
2
No data yet
2
2
No data yet
2
2
No data yet
1
1
Please enter your data:
je m'appele walid
je m'appele walid
Please enter the length of your data:
50
50
Your entry number is: 1
Write successful, would you like to do anything else?


No data given.
Please put in a valid number
2
2
Please enter the entry number of your data:
1
1
je m'appele walid
Read successful, would you like to do anything else?
2
2
Please enter the entry number of your data:
0
0
picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_68466E2F}
```

Appearantly, the flag was in the input number 0, since it added the first data in the input number of 1

But when you do it again using a string or a char, it shows :

```
Hi, welcome to my echo chamber!
Type '1' to enter a phrase into our database
Type '2' to echo a phrase in our database
Type '3' to exit the program
2
2
No data yet
o
o
Please put in a valid number
1
1
Please enter your data:
olk
olk
Please enter the length of your data:
90
90
Your entry number is: 1
Write successful, would you like to do anything else?
2
2
Please enter the entry number of your data:
a
a
picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_68466E2F}

```

This is because, when the database has some data, it calls the data_read() function, which with an expected number or a string, prints the flag.

in this function contains the following code :
```
if ((entry_number = strtol(entry, NULL, 10)) == 0) {
	puts(flag);
	fseek(stdin, 0, SEEK_END);
	exit(0);
}
```

which will lead us to check in the manual the role of strtol using `man strtol` :

```man
STRTOL(3)                                                                                               Library Functions Manual                                                                                              STRTOL(3)

NAME
       strtol, strtoll, strtoq - convert a string to a long integer

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <stdlib.h>

       long strtol(const char *restrict nptr,
                   char **restrict endptr, int base);
       long long strtoll(const char *restrict nptr,
                   char **restrict endptr, int base);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       strtoll():
           _ISOC99_SOURCE
               || /* Glibc <= 2.19: */ _SVID_SOURCE || _BSD_SOURCE

DESCRIPTION
       The strtol() function converts the initial part of the string in nptr to a long integer value according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.

       The  string  may  begin  with an arbitrary amount of white space (as determined by isspace(3)) followed by a single optional '+' or '-' sign.  If base is zero or 16, the string may then include a "0x" or "0X" prefix, and the
       number will be read in base 16; otherwise, a zero base is taken as 10 (decimal) unless the next character is '0', in which case it is taken as 8 (octal).

       The remainder of the string is converted to a long value in the obvious manner, stopping at the first character which is not a valid digit in the given base.  (In bases above 10, the letter 'A' in either uppercase or  lower‐
       case represents 10, 'B' represents 11, and so forth, with 'Z' representing 35.)

       If  endptr  is not NULL, strtol() stores the address of the first invalid character in *endptr.  If there were no digits at all, strtol() stores the original value of nptr in *endptr (and returns 0).  In particular, if *nptr
       is not '\0' but **endptr is '\0' on return, the entire string is valid.

       The strtoll() function works just like the strtol() function but returns a long long integer value.

```

The manual says that the ... function converts the initial part of the string in nptr(our entry variable)to a long integer value according to the given base .... So, in our case, the content of the entry variable, which is what we gave in input to the program, is converted to a long integer in base 10. This value is then returned in the entry_number variable. So we can give a 0 in input, which will be converted to a 0 by the function. In this way the execution enters the block, where the flag is printed with the put() function.

Of course, if the database is empty, you can't access the data_read() function. so make sure you add an entry first.

flag : picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_68466E2F}

More information :
https://github.com/0xs3pi0l/CTF_writeups/blob/main/PicoCTF2022/basic_file_exploit/writeup.md
https://www.it-sec.fail/picoctf-2022-binary-exploitation-basic-file-exploit/
https://tzion0.github.io/posts/picoctf2022-binexp/
